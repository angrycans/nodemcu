<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <title>Acans 7-Axis Control Console</title>
    <link rel="stylesheet" href="./main.css">
</head>
<script src="./main.js"></script>
<script type="module" src="https://unpkg.com/esp-web-tools@9/dist/web/install-button.js?module"></script>
<body>

    <header>
        <button id="connectBtn" class="disable" onclick="connect()">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 3h2v4h2V3h2v4h2a3 3 0 0 1 3 3v3h-2V10a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v3H6v-3a3 3 0 0 1 3-3h2V3zm10 12v2a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4v-2h2v2a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-2h2z" fill="currentColor"/>
            </svg>
            <span id="connectText">Connect Serial</span>
        </button>


        <span id="status">Disconnected</span>
        <span id="fwStatus">FW: -</span>
        <div class="fw-wrap">
        <button id="fwUpdateBtn" class="fw-update" onclick="requestFirmwareUpdate()">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 3l4.5 5h-3v6h-3V8h-3L12 3zm-7 14h14v2H5v-2z" fill="currentColor" />
            </svg>
            <span id="fwUpdateText">Firmware Update</span>
        </button>
            <div id="fwMenu" class="fw-menu hidden">
                <div class="fw-menu-title" data-i18n="fw_list">Firmware List</div>
                <div id="fwList" class="fw-list"></div>
            </div>
        </div>
        <button id="contactBtn" class="contact-btn" onclick="openContact()">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 6h16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2zm0 2v.2l8 4.8 8-4.8V8H4zm16 8v-5.1l-7.5 4.5a1 1 0 0 1-1 0L4 10.9V16h16z" fill="currentColor"/>
            </svg>
            <span data-i18n="contact">Contact</span>
        </button>
        <button id="langToggleBtn" class="contact-btn" onclick="toggleLang()">
            <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 2a10 10 0 1 0 0 20a10 10 0 0 0 0-20zm6.5 10a8.5 8.5 0 0 1-1.6 4.9h-3a17.6 17.6 0 0 0 .8-4.9h3.8zm-5.1 0a15.6 15.6 0 0 1-1.4 6.2A15.6 15.6 0 0 1 10.6 12h2.8zM12 4.1c.8 1.1 1.5 3 1.8 5.9h-3.6c.3-2.9 1-4.8 1.8-5.9zM7.1 7.1A8.5 8.5 0 0 1 10 4.1a17.6 17.6 0 0 0-.8 5.9H5.5a8.5 8.5 0 0 1 1.6-2.9zM5.5 12h3.8a17.6 17.6 0 0 0 .8 4.9h-3A8.5 8.5 0 0 1 5.5 12zm5.1 0a15.6 15.6 0 0 1 1.4-6.2A15.6 15.6 0 0 1 13.4 12h-2.8zm3.4 6.9a8.5 8.5 0 0 1-2.9 2.9a17.6 17.6 0 0 0 .8-5.9h3a8.5 8.5 0 0 1-.9 3zM18.5 10h-3.8a17.6 17.6 0 0 0-.8-5.9a8.5 8.5 0 0 1 4.6 5.9z" fill="currentColor"/>
            </svg>
            <span class="lang-label" id="langToggleText">中文</span>
        </button>
    </header>

    <div class="container disabled" id="container">
        <!-- Top toolbar -->
        <div class="axis-toolbar">
            <label class="auto-home-toggle">
                <input type="checkbox" id="autoHomeToggle" onchange="setAutoHome(this.checked)">
                <span data-i18n="auto_home">Auto Home</span>
            </label>
            <button id="consoleToggleBtn" class="console-toggle active" onclick="toggleConsole()">
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M4 5h16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2zm0 2v8h16V7H4zm3 12h10v2H7v-2z" fill="currentColor"/>
                </svg>
                <span data-i18n="console">Console</span>
            </button>
            <button class="home-homed" onclick="send('HOME ALL')">
                <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 3l9 7h-3v9h-5v-6H11v6H6v-9H3l9-7z" fill="currentColor"/>
                </svg>
                <span data-i18n="home_all">Home All</span>
            </button>
        </div>
        <div class="axis-area" id="axisArea"></div>
        <div class="console-panel" id="consolePanel">
            <div class="console-header">
                <div class="console-title" data-i18n="console_output">Console Output</div>
                <button class="console-clear" onclick="clearConsole()">
                    <svg class="btn-icon" viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M7 5h10l1 2h4v2H2V7h4l1-2zm1 6h2v7H8v-7zm4 0h2v7h-2v-7zm4 0h2v7h-2v-7z" fill="currentColor"/>
                    </svg>
                    <span data-i18n="clear">Clear</span>
                </button>
            </div>
            <div class="console-body" id="consoleBody"></div>
        </div>

    </div>
    <div id="toastContainer" class="toast-container"></div>
    <div id="contactOverlay" class="modal-overlay hidden" onclick="closeContact()">
        <div class="modal-card" onclick="event.stopPropagation()">
            <div class="modal-title" data-i18n="contact_title">Contact Info</div>
            <div class="modal-body" data-i18n="contact_email">Email: angrycans@gmail.com</div>
            <!-- <div class="modal-body" data-i18n="contact_wechat">WeChat: angrycans</div> -->
            <div class="modal-actions">
                <button class="modal-close" onclick="closeContact()" data-i18n="close">Close</button>
            </div>
        </div>
    </div>

    <script>
        /* ================= Config ================= */
        const AXIS_NUM = 7;
        let activeAxisCount = AXIS_NUM;
        const SHELL_TOP = 10;
        const SHELL_HEIGHT = 140;
        const ROD_HEIGHT = 20;
        const POS_MAXI = 65535;
        const FLYPT_SEND_INTERVAL_MS = 30;

        const HOME_IDLE = 0;
        const HOME_HOMING = 1;
        const HOME_HOMED = 2;
        const HOME_FAILED = 3;

        const I18N = {
            en: {
                connect: "Connect Serial",
                disconnect: "Disconnect",
                disconnected: "Disconnected",
                connected: "Connected",
                fw_update: "Firmware Update",
                fw_list: "Firmware List",
                contact: "Contact",
                contact_title: "Contact Info",
                contact_email: "Email: angrycans@gmail.com",
                contact_wechat: "WeChat: angrycans",
                close: "Close",
                console: "Console",
                home_all: "Home All",
                console_output: "Console Output",
                clear: "Clear",
                no_firmware: "No firmware",
                sync_ok: "Parameters synced",
                sync_fail: "Parameter sync failed",
                need_disconnect: "Please disconnect serial first",
                fw_load_fail: "Failed to load firmware list",
                fw_bad: "Firmware files unavailable or corrupted",
                serial_disconnected: "Serial disconnected",
                serial_read_fail: "Serial read failed",
                stroke: "Stroke",
                lead: "Lead",
                motor_reverse: "Motor Reverse",
                manual_home: "Manual Home",
                update_available: " (Update available)",
                auto_home: "Auto Home"
                ,enabled: "ENABLED"
                ,disabled: "DISABLED"
                ,home: "Home"
            },
            zh: {
                connect: "连接串口",
                disconnect: "断开连接",
                disconnected: "未连接",
                connected: "已连接",
                fw_update: "固件更新",
                fw_list: "固件列表",
                contact: "联系我",
                contact_title: "联系信息",
                contact_email: "邮箱: angrycans@gmail.com",
                contact_wechat: "微信: angrycans",
                close: "关闭",
                console: "控制台",
                home_all: "归零全部",
                console_output: "控制台输出",
                clear: "清空",
                no_firmware: "暂无固件",
                sync_ok: "参数已同步",
                sync_fail: "参数同步失败",
                need_disconnect: "请先断开串口",
                fw_load_fail: "固件列表加载失败",
                fw_bad: "固件文件不可用或损坏",
                serial_disconnected: "串口已断开",
                serial_read_fail: "串口读取失败",
                stroke: "行程",
                lead: "导程",
                motor_reverse: "电机反向",
                manual_home: "手动归零",
                update_available: "（有可用更新）",
                auto_home: "自动归零"
                ,enabled: "已启用"
                ,disabled: "已禁用"
                ,home: "归零"
            }
        };

        let currentLang = "zh";
        let currentFwVersion = "";
        let currentBoardType = "";

        function t(key) {
            const dict = I18N[currentLang] || I18N.en;
            return dict[key] || key;
        }

        function applyLang() {
            document.querySelectorAll("[data-i18n]").forEach((el) => {
                const key = el.getAttribute("data-i18n");
                el.textContent = t(key);
            });

            const connectText = document.getElementById("connectText");
            if (connectText) {
                const connected = !!(port || writer);
                connectText.textContent = connected ? t("disconnect") : t("connect");
            }

            const fwText = document.getElementById("fwUpdateText");
            if (fwText) fwText.textContent = t("fw_update");

            const status = document.getElementById("status");
            if (status) {
                const connected = !!(port || writer);
                status.textContent = connected ? t("connected") : t("disconnected");
            }

            updateLangToggleBtn();
            updateFwStatusText();
            renderFirmwareList(firmwareCache || []);
            updateAxisTexts();
        }

        function toggleLang() {
            currentLang = currentLang === "en" ? "zh" : "en";
            applyLang();
        }

        function updateLangToggleBtn() {
            const label = document.getElementById("langToggleText");
            if (!label) return;
            label.textContent = currentLang === "en" ? "EN" : "中文";
        }

        function updateAxisTexts() {
            for (let i = 0; i < AXIS_NUM; i++) {
                const enBtn = document.getElementById(`enBtn${i}`);
                if (enBtn) {
                    enBtn.textContent = axis[i].enabled ? t("enabled") : t("disabled");
                }
                const homeBtn = document.getElementById(`homeBtn${i}`);
                if (homeBtn) homeBtn.textContent = t("home");
            }
        }


        /* ================= Web Serial ================= */
        let port, writer, reader;
        let consoleBuffer = "";
        let consoleLines = [];
        const CONSOLE_MAX_LINES = 500;
        const serialListeners = [];
        let isDisconnecting = false;



        async function connect() {
                console.log("Connecting...");
            // If already connected, disconnect first
            if (port || writer) {
                console.log("Already connected, disconnecting first...");
                await disconnect();
            }

            try {
                console.log("Requesting serial port...");
                port = await navigator.serial.requestPort();
                console.log("Opening serial port...");
                await port.open({ baudRate: 115200 });
                writer = port.writable.getWriter();
                console.log("Serial connected, writer ready");
                document.getElementById("status").textContent = t("connected");
                // Update button
                const btn = document.getElementById("connectBtn");
                const connectText = document.getElementById("connectText");
                if (connectText) connectText.textContent = t("disconnect");
                btn.classList.remove("disable");
                btn.classList.add("enable");
                btn.onclick = disconnect;
                startSerialRead();
                await queryBoardName();
                document.getElementById("container").classList.remove("disabled");

                console.log("Connected, button updated");

            } catch (err) {
                console.error("Connection failed:", err);
                // Ensure state is reset on failure
                writer = null;
                port = null;
                const btn = document.getElementById("connectBtn");
                const connectText = document.getElementById("connectText");
                if (connectText) connectText.textContent = t("connect");
                btn.classList.remove("enable");
                btn.classList.add("disable");
                btn.onclick = connect;
                console.log("Connection failed, state reset");
            }
        }

        async function disconnect() {
            if (!port || isDisconnecting) return;
            isDisconnecting = true;

            try {
                // 1️⃣ Stop reader
                if (reader) {
                    const currentReader = reader;
                    try {
                        await currentReader.cancel();
                    } catch (err) {
                        console.warn("reader.cancel failed:", err);
                    }
                    try {
                        currentReader.releaseLock();
                    } catch (err) {
                        console.warn("reader.releaseLock failed:", err);
                    }
                    reader = null;
                }

                // 2️⃣ Release writer
                if (writer) {
                    try {
                        await writer.ready;
                    } catch (err) {
                        console.warn("writer.ready failed:", err);
                    }
                    try {
                        writer.releaseLock();
                    } catch (err) {
                        console.warn("writer.releaseLock failed:", err);
                    }
                    writer = null;
                }

                // 3️⃣ Close serial port
                try {
                    await port.close();
                } catch (err) {
                    console.warn("port.close failed:", err);
                }
                port = null;

                // 4️⃣ Update UI
                document.getElementById("status").textContent = t("disconnected");

                const btn = document.getElementById("connectBtn");
                const connectText = document.getElementById("connectText");
                if (connectText) connectText.textContent = t("connect");
                btn.classList.remove("enable");
                btn.classList.add("disable");
                btn.onclick = connect;
                document.getElementById("container").classList.add("disabled");

                console.log("Serial disconnected (port.close done)");
            } catch (err) {
                console.error("Disconnect failed:", err);
            } finally {
                isDisconnecting = false;
            }
        }

        function send(cmd) {
            console.log(cmd);
            if (!writer) return;
            emitSerialEvent({ direction: "TX", line: cmd });
            writer.write(new TextEncoder().encode(cmd + "\n"));
        }

        let lastFlyptSendMs = 0;
        let flyptRawCache = new Uint16Array(AXIS_NUM);

        function updateFlyptCacheForAxis(i) {
            const stroke = Number(axis[i].stroke) || 1;
            let raw = Math.round((axis[i].target / stroke) * POS_MAXI);
            if (raw < 0) raw = 0;
            if (raw > POS_MAXI) raw = POS_MAXI;
            flyptRawCache[i] = raw;
        }

        function sendFlyptFrame() {
            if (!writer) return;
            const now = Date.now();
            if (now - lastFlyptSendMs < FLYPT_SEND_INTERVAL_MS) return;
            lastFlyptSendMs = now;
            const frame = new Uint8Array(2 + activeAxisCount * 2 + 2);
            frame[0] = "Y".charCodeAt(0);
            frame[1] = "7".charCodeAt(0);

            for (let i = 0; i < activeAxisCount; i++) {
                const raw = flyptRawCache[i];
                const hi = (raw >> 8) & 0xff;
                const lo = raw & 0xff;
                const offset = 2 + i * 2;
                frame[offset] = hi;
                frame[offset + 1] = lo;
            }

            frame[frame.length - 2] = "!".charCodeAt(0);
            frame[frame.length - 1] = "!".charCodeAt(0);

            const frameText = Array.from(frame)
                .map((v) => String(v).padStart(3, "0"))
                .join(" ");
            emitSerialEvent({ direction: "TX", line: frameText });
            writer.write(frame);
        }

        /* ================= Console ================= */
        function toggleConsole() {
            const panel = document.getElementById("consolePanel");
            const btn = document.getElementById("consoleToggleBtn");
            const isHidden = panel.classList.contains("hidden");

            if (isHidden) {
                panel.classList.remove("hidden");
                btn.classList.add("active");
            } else {
                panel.classList.add("hidden");
                btn.classList.remove("active");
            }
        }

        function clearConsole() {
            consoleLines = [];
            document.getElementById("consoleBody").textContent = "";
        }

        function formatTimestamp(dateObj) {
            const pad = (n, len = 2) => String(n).padStart(len, "0");
            const hh = pad(dateObj.getHours());
            const mm = pad(dateObj.getMinutes());
            const ss = pad(dateObj.getSeconds());
            return `${hh}:${mm}:${ss}`;
        }

        function appendConsoleLine(direction, text) {
            const ts = formatTimestamp(new Date());
            const label = direction === "TX" ? "TX>" : "RX>";
            const line = `[${ts}] ${label} ${text}`;
            consoleLines.push({ direction, line });

            if (consoleLines.length > CONSOLE_MAX_LINES) {
                consoleLines = consoleLines.slice(-CONSOLE_MAX_LINES);
            }

            const body = document.getElementById("consoleBody");
            body.innerHTML = "";
            for (const item of consoleLines) {
                const div = document.createElement("div");
                div.classList.add("console-line");
                if (item.direction === "TX") div.classList.add("console-tx");
                if (item.direction === "RX") div.classList.add("console-rx");
                div.textContent = item.line;
                body.appendChild(div);
            }
            body.scrollTop = body.scrollHeight;
        }

        function addSerialListener(fn) {
            serialListeners.push(fn);
            return () => {
                const idx = serialListeners.indexOf(fn);
                if (idx >= 0) serialListeners.splice(idx, 1);
            };
        }

        function emitSerialEvent(evt) {
            appendConsoleLine(evt.direction, evt.line);
            for (const fn of serialListeners) {
                try {
                    fn(evt);
                } catch (err) {
                    console.error("serial listener error:", err);
                }
            }
        }

        function waitForLinePrefix(prefix, timeoutMs = 800) {
            return new Promise((resolve, reject) => {
                const cleanup = () => {
                    if (off) off();
                    if (timer) clearTimeout(timer);
                };
                const off = addSerialListener((evt) => {
                    if (evt.direction === "RX" && evt.line.startsWith(prefix)) {
                        cleanup();
                        resolve(evt.line);
                    }
                });
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error("timeout"));
                }, timeoutMs);
            });
        }

        async function handleSerialDisconnect(message) {
            await disconnect();
            showToast(message || t("serial_disconnected"));
        }

        let toastTimer = null;
        function showToast(message, duration = 2200) {
            const container = document.getElementById("toastContainer");
            container.textContent = message;
            container.classList.add("show");
            if (toastTimer) clearTimeout(toastTimer);
            toastTimer = setTimeout(() => {
                container.classList.remove("show");
            }, duration);
        }

        function requestFirmwareUpdate() {
            if (port || writer) {
                showToast(t("need_disconnect"));
                return;
            }
            toggleFirmwareMenu();
        }

        let firmwareCache = null;
        let firmwareLoading = false;
        let firmwareMenuOpen = false;
        let latestFirmware = null;

        function toggleFirmwareMenu() {
            const menu = document.getElementById("fwMenu");
            if (!menu) return;
            firmwareMenuOpen = !firmwareMenuOpen;
            if (firmwareMenuOpen) {
                menu.classList.remove("hidden");
                if (!firmwareCache && !firmwareLoading) {
                    loadFirmwareList();
                }
            } else {
                menu.classList.add("hidden");
            }
        }

        async function loadFirmwareList() {
            firmwareLoading = true;
            try {
                const resp = await fetch("./firmware/firmwares.json", { cache: "no-store" });
                if (!resp.ok) throw new Error("manifest load failed");
                const data = await resp.json();
                firmwareCache = Array.isArray(data.firmwares) ? data.firmwares : [];
                firmwareCache.sort((a, b) => (b.ts || 0) - (a.ts || 0));
                latestFirmware = firmwareCache.length ? firmwareCache[0] : null;
                renderFirmwareList(firmwareCache);
                updateFwStatusText();
            } catch (err) {
                console.error("loadFirmwareList failed:", err);
                renderFirmwareList([]);
                showToast(t("fw_load_fail"));
            } finally {
                firmwareLoading = false;
            }
        }

        function renderFirmwareList(list) {
            const container = document.getElementById("fwList");
            if (!container) return;
            container.innerHTML = "";

            if (!list || list.length === 0) {
                const empty = document.createElement("div");
                empty.className = "fw-empty";
                empty.textContent = t("no_firmware");
                container.appendChild(empty);
                return;
            }

            for (const item of list) {
                const row = document.createElement("div");
                row.className = "fw-item";

                const info = document.createElement("div");
                info.className = "fw-info";
                const title = document.createElement("div");
                title.className = "fw-title";
                title.textContent = item.name || "Firmware";
                info.appendChild(title);

                const actions = document.createElement("div");
                actions.className = "fw-actions";

                const cacheBust = item.ts ? `?v=${item.ts}` : `?v=${Date.now()}`;
                const dir = item.dir ? `${item.dir}/` : "";

                const install = document.createElement("esp-web-install-button");
                const manifestName = item.installManifest;
                install.classList.add("fw-install");
                install.setAttribute("disabled", "");

                actions.appendChild(install);

                row.appendChild(info);
                row.appendChild(actions);
                container.appendChild(row);

                validateFirmware(item, cacheBust, install, manifestName, dir);
            }
        }

        function parseVersionParts(v) {
            if (!v) return [];
            return String(v)
                .trim()
                .replace(/^v/i, "")
                .split(".")
                .map((x) => parseInt(x, 10))
                .map((n) => (Number.isFinite(n) ? n : 0));
        }

        function compareVersions(a, b) {
            const pa = parseVersionParts(a);
            const pb = parseVersionParts(b);
            const len = Math.max(pa.length, pb.length);
            for (let i = 0; i < len; i++) {
                const va = pa[i] || 0;
                const vb = pb[i] || 0;
                if (va > vb) return 1;
                if (va < vb) return -1;
            }
            return 0;
        }

        function updateFwStatusText() {
            const fw = document.getElementById("fwStatus");
            if (!fw) return;
            const current = currentFwVersion || "";
            const typeLabel = currentBoardType ? ` ${currentBoardType}` : "";
            if (!current || !latestFirmware || !latestFirmware.version) return;

            const hasUpdate = compareVersions(latestFirmware.version, current) > 0;
            fw.textContent = `FW: ${current}${typeLabel}${hasUpdate ? t("update_available") : ""}`;
        }

        async function fetchArrayBuffer(path) {
            const resp = await fetch(path, { cache: "no-store" });
            if (!resp.ok) throw new Error(`fetch failed: ${path}`);
            return await resp.arrayBuffer();
        }

        function hasValidHeader(buf, offset = 0) {
            if (!buf || buf.byteLength < offset + 1) return false;
            const view = new Uint8Array(buf, offset, 1);
            return view[0] !== 0xff;
        }

        async function validateFirmware(item, cacheBust, installEl, manifestName, dir) {
            try {
                await fetchArrayBuffer(`./firmware/${dir}${manifestName}${cacheBust}`);

                const app = await fetchArrayBuffer(`./firmware/${dir}${item.bin}${cacheBust}`);
                if (!hasValidHeader(app, 0)) {
                    throw new Error("invalid app header");
                }
                const boot = await fetchArrayBuffer(`./firmware/${dir}${item.name}_bootloader.bin${cacheBust}`);
                const part = await fetchArrayBuffer(`./firmware/${dir}${item.name}_partitions.bin${cacheBust}`);
                const app0 = await fetchArrayBuffer(`./firmware/${dir}${item.name}_boot_app0.bin${cacheBust}`);
                if (!hasValidHeader(boot, 0) || !hasValidHeader(part, 0) || !hasValidHeader(app0, 0)) {
                    throw new Error("invalid segment header");
                }

                installEl.removeAttribute("disabled");
                installEl.setAttribute("manifest", `./firmware/${dir}${manifestName}${cacheBust}`);
            } catch (err) {
                console.error("validateFirmware failed:", err);
                showToast(t("fw_bad"));
            }
        }

        document.addEventListener("click", (evt) => {
            const menu = document.getElementById("fwMenu");
            const wrap = document.querySelector(".fw-wrap");
            if (!menu || !wrap) return;
            if (!firmwareMenuOpen) return;
            if (wrap.contains(evt.target)) return;
            firmwareMenuOpen = false;
            menu.classList.add("hidden");
        });

        function openContact() {
            const overlay = document.getElementById("contactOverlay");
            if (overlay) overlay.classList.remove("hidden");
        }

        function closeContact() {
            const overlay = document.getElementById("contactOverlay");
            if (overlay) overlay.classList.add("hidden");
        }

        async function startSerialRead() {
            if (!port || reader) return;
            const decoder = new TextDecoder();
            consoleBuffer = "";

            try {
                reader = port.readable.getReader();
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        await handleSerialDisconnect(t("serial_disconnected"));
                        break;
                    }
                    if (!value) continue;

                    consoleBuffer += decoder.decode(value, { stream: true });
                    const lines = consoleBuffer.split("\n");
                    consoleBuffer = lines.pop() || "";

                    for (const raw of lines) {
                        const line = raw.replace(/\r/g, "").trim();
                        if (line.length === 0) continue;
                        const cleaned = line.replace(/[^\x20-\x7E]/g, "");
                        if (cleaned.length === 0) continue;
                        const normalized = normalizeRxLine(cleaned);
                        if (!normalized) continue;
                        emitSerialEvent({ direction: "RX", line: normalized });
                    }
                }
            } catch (err) {
                console.error(t("serial_read_fail") + ":", err);
                await handleSerialDisconnect(t("serial_disconnected"));
            } finally {
                if (reader) {
                    reader.releaseLock();
                    reader = null;
                }
            }
        }

        function normalizeRxLine(line) {
            const boardIdx = line.indexOf("BOARD:");
            const cfgIdx = line.indexOf("CFG ");
            let cutIdx = -1;

            if (boardIdx >= 0) cutIdx = boardIdx;
            if (cfgIdx >= 0 && (cutIdx === -1 || cfgIdx < cutIdx)) cutIdx = cfgIdx;

            if (cutIdx >= 0) {
                return line.slice(cutIdx);
            }

            return line;
        }

        /* ================= Axis Data ================= */
        let axis = Array.from({ length: AXIS_NUM }, () => ({
            stroke: 100,
            lead: 5.0,
            invert: false,
            target: 0,
            enabled: true,
            homeState: HOME_IDLE   // 3-state
        }));

        function setActiveAxisCount(count) {
            const next = Math.max(1, Math.min(AXIS_NUM, Number(count) || AXIS_NUM));
            if (next === activeAxisCount) return;
            activeAxisCount = next;
            for (let i = 0; i < AXIS_NUM; i++) {
                const card = document.getElementById(`axisCard${i}`);
                if (!card) continue;
                if (i < activeAxisCount) {
                    card.classList.remove("hidden");
                } else {
                    card.classList.add("hidden");
                }
            }
        }
        /* ================= SVG Components ================= */
        function axisSVG(i) {
            return `
<svg width="80" height="160">
  <!-- Shell -->
  <rect id="shell${i}" x="20" y="${SHELL_TOP}" width="40" height="${SHELL_HEIGHT}"
        rx="6" fill="#555" stroke="#777"
        stroke-width="2"/>
  <!-- Slider -->
  <rect id="rod${i}" x="28" y="${SHELL_TOP + SHELL_HEIGHT - ROD_HEIGHT}"
        width="24" height="${ROD_HEIGHT}" rx="4" fill="#777"/>
</svg>`;
        }

        /* ================= UI Build ================= */
        const container = document.getElementById("axisArea");

        axis.forEach((a, i) => {
            container.innerHTML += `
  <div class="axis" id="axisCard${i}">
    <div style="text-align: center">
    <button id="enBtn${i}" onclick="toggleEnable(${i})">
    ${t("disabled")}</button>
    </div>
    <h3>Axis ${i + 1}</h3> 
  

    ${axisSVG(i)}

    <div class="value" id="val${i}">0.0 mm</div>

    <input type="range"
  id="slider${i}"
  min="0"
  max="${a.stroke}"
  value="0"
  oninput="moveAxis(${i}, this.value)">

    <label data-i18n="stroke">${t("stroke")}</label><br>
    <input type="number" value="${a.stroke}"
      id="stroke${i}"
      onchange="setStroke(${i}, this.value)"> mm<br>

    <label data-i18n="lead">${t("lead")}</label><br>
    <input type="number" step="0.1" value="${a.lead}"
      id="lead${i}"
      onchange="setLead(${i}, this.value)"> mm/rev<br>

    <label>
      <input type="checkbox"
        id="invert${i}"
        onchange="setInvert(${i}, this.checked)">
      <span data-i18n="motor_reverse">${t("motor_reverse")}</span>
    </label>

    <div class="controls">
     <div class="controls">
<button id="homeBtn${i}" onclick="homeAxis(${i})">${t("home")}</button>
 <label class="manual-home">
   <input type="checkbox" id="manualHome${i}" onchange="setManualHome(${i}, this.checked)">
   <span data-i18n="manual_home">${t("manual_home")}</span>
 </label>
</div>

    </div>
  </div>
  `;
        });

        /* ================= Control Logic ================= */
        function moveAxis(i, value) {
            if (!(axis[i].enabled && axis[i].homeState === HOME_HOMED)) {
                return;
            }


            axis[i].target = Number(value);
            updateRod(i);

            updateFlyptCacheForAxis(i);
            sendFlyptFrame();
        }

        function setStroke(i, v) {
            const stroke = Number(v);
            axis[i].stroke = stroke;

            const slider = document.getElementById(`slider${i}`);
            slider.max = stroke;

            // Prevent target exceeding new stroke
            if (axis[i].target > stroke) {
                axis[i].target = stroke;
                slider.value = stroke;
            }

            updateRod(i);
            send(`SET STROKE ${i} ${stroke}`);
        }


        function setLead(i, v) {
            axis[i].lead = Number(v);
            send(`SET LEAD ${i} ${v}`);
        }

        function setInvert(i, v) {
            // UI: reverse checked => invert = false
            axis[i].invert = !v;
            send(`SET INVERT ${i} ${axis[i].invert ? 1 : 0}`);
        }

        function setAutoHome(enabled) {
            send(`SET AUTO_HOME ${enabled ? 1 : 0}`);
        }

        /* ================= SVG Update ================= */
        function updateRod(i) {
            const a = axis[i];
            const ratio = a.target / a.stroke;
            const maxTravel = SHELL_HEIGHT - ROD_HEIGHT;

            const y = SHELL_TOP + maxTravel * (1 - ratio);

            document.getElementById(`rod${i}`).setAttribute("y", y);
            document.getElementById(`val${i}`).textContent =
                a.target.toFixed(1) + " mm";
        }

        function toggleEnable(i) {
            axis[i].enabled = !axis[i].enabled;

            const btn = document.getElementById(`enBtn${i}`);

            if (axis[i].enabled) {
                btn.textContent = t("enabled");
                btn.classList.remove("disable");
                btn.classList.add("enable");
                send(`ENABLE AXIS ${i}`);
            } else {
                btn.textContent = t("disabled");
                btn.classList.remove("enable");
                btn.classList.add("disable");

                axis[i].homeState = HOME_IDLE; // Key
                send(`DISABLE AXIS ${i}`);
            }

            updateAxisUI(i);
        }


        function updateAxisUI(i) {
            const a = axis[i];

            const slider = document.getElementById(`slider${i}`);
            const rod = document.getElementById(`rod${i}`);
            const shell = document.getElementById(`shell${i}`);
            const homeBtn = document.getElementById(`homeBtn${i}`);

            let canMove = false;
            let rodColor = "#c62828";
            let homeClass = "home-idle";


            if (!a.enabled) {
                canMove = false;
                rodColor = "#c62828";
                homeClass = "home-idle";

            } else {
                switch (a.homeState) {
                    case HOME_IDLE:
                        canMove = false;
                        rodColor = "#777";
                        homeClass = "home-idle";
                        break;

                    case HOME_HOMING:
                        canMove = false;
                        rodColor = "#f9a825";
                        homeClass = "home-homing";
                        break;

                    case HOME_HOMED:
                        canMove = true;
                        rodColor = "#4CAF50";
                        homeClass = "home-homed";
                        break;
                    case HOME_FAILED:
                        canMove = false;
                        rodColor = "#f6010a";
                        homeClass = "home-failed";
                        break;
                }
            }

            slider.disabled = !canMove;
            rod.setAttribute("fill", rodColor);

            // Home button color
            homeBtn.classList.remove("home-idle", "home-homing", "home-homed", "home-failed");
            homeBtn.classList.add(homeClass);

            // Shell stroke: Enable = green, Disable = gray
            shell.setAttribute(
                "stroke",
                a.enabled ? "#4CAF50" : "#777"
            );

        }

        function applyConfigFromJson(cfg) {
            if (!cfg) return;
            if (Array.isArray(cfg.stroke) && cfg.stroke.length > 0) {
                setActiveAxisCount(Math.min(AXIS_NUM, cfg.stroke.length));
            }
            for (let i = 0; i < activeAxisCount; i++) {
                if (Array.isArray(cfg.stroke) && cfg.stroke[i] != null) {
                    axis[i].stroke = Number(cfg.stroke[i]);
                }
                if (Array.isArray(cfg.lead) && cfg.lead[i] != null) {
                    axis[i].lead = Number(cfg.lead[i]);
                }
                if (Array.isArray(cfg.invert) && cfg.invert[i] != null) {
                    axis[i].invert = Number(cfg.invert[i]) === 1;
                }
                if (Array.isArray(cfg.enable) && cfg.enable[i] != null) {
                    axis[i].enabled = Number(cfg.enable[i]) === 1;
                    if (!axis[i].enabled) {
                        axis[i].homeState = HOME_IDLE;
                    }
                }

                const slider = document.getElementById(`slider${i}`);
                const strokeInput = document.getElementById(`stroke${i}`);
                const leadInput = document.getElementById(`lead${i}`);
                const invertInput = document.getElementById(`invert${i}`);

                if (strokeInput) strokeInput.value = axis[i].stroke;
                if (leadInput) leadInput.value = axis[i].lead;
                if (invertInput) invertInput.checked = !axis[i].invert;

                if (slider) {
                    slider.max = axis[i].stroke;
                    if (axis[i].target > axis[i].stroke) {
                        axis[i].target = axis[i].stroke;
                    }
                    slider.value = axis[i].target;
                }

                const btn = document.getElementById(`enBtn${i}`);
                if (btn) {
                    if (axis[i].enabled) {
                        btn.textContent = t("enabled");
                        btn.classList.remove("disable");
                        btn.classList.add("enable");
                    } else {
                        btn.textContent = t("disabled");
                        btn.classList.remove("enable");
                        btn.classList.add("disable");
                    }
                }

                updateRod(i);
                updateAxisUI(i);
            }

            if (cfg.auto_home != null) {
                const autoHomeToggle = document.getElementById("autoHomeToggle");
                if (autoHomeToggle) {
                    autoHomeToggle.checked = Number(cfg.auto_home) === 1;
                }
            }
        }

        function applyHomeFromJson(data) {
            if (!data || !Array.isArray(data.state)) return;
            setActiveAxisCount(Math.min(AXIS_NUM, data.state.length));
            for (let i = 0; i < activeAxisCount; i++) {
                if (data.state[i] == null) continue;
                const state = Number(data.state[i]);
                if (state === HOME_HOMED) {
                    axis[i].target = 0;
                    const slider = document.getElementById(`slider${i}`);
                    if (slider) slider.value = 0;
                    updateRod(i);
                    updateFlyptCacheForAxis(i);
                    axis[i].homeState = HOME_HOMED;
                } else if (state === HOME_HOMING) {
                    axis[i].homeState = HOME_HOMING;
                } else if (state === HOME_FAILED) {
                    axis[i].homeState = HOME_FAILED;
                } else {
                    axis[i].homeState = HOME_IDLE;
                }
                updateAxisUI(i);
            }
        }


        function homeAxis(i) {
            if (!axis[i].enabled) return;

            axis[i].homeState = HOME_HOMING;
            updateAxisUI(i);

            send(`HOME AXIS ${i}`);
        }

        function setManualHome(i, checked) {
            if (!axis[i].enabled) return;
            if (checked) {
                axis[i].homeState = HOME_HOMED;
                axis[i].target = 0;
                const slider = document.getElementById(`slider${i}`);
                if (slider) slider.value = 0;
                updateRod(i);
                updateFlyptCacheForAxis(i);
                send(`HOME OK ${i}`);
            } else {
                axis[i].homeState = HOME_IDLE;
            }
            updateAxisUI(i);
        }

        function init() {
            for (let i = 0; i < AXIS_NUM; i++) {
                const btn = document.getElementById(`enBtn${i}`);
                btn.textContent = t("enabled");
                btn.classList.remove("disable");
                btn.classList.add("enable");

                axis[i].enabled = true;
                axis[i].homeState = HOME_IDLE;


                updateAxisUI(i);

            }
            for (let i = 0; i < AXIS_NUM; i++) {
                updateFlyptCacheForAxis(i);
            }


        }

        function registerSerialHandlers() {
            function extractJsonObject(text) {
                const first = text.indexOf("{");
                if (first === -1) return null;
                let start = -1;
                let depth = 0;
                let inString = false;
                let escape = false;
                for (let i = first; i < text.length; i++) {
                    const ch = text[i];
                    if (inString) {
                        if (escape) {
                            escape = false;
                            continue;
                        }
                        if (ch === "\\") {
                            escape = true;
                            continue;
                        }
                        if (ch === "\"") {
                            inString = false;
                        }
                        continue;
                    }
                    if (ch === "\"") {
                        inString = true;
                        continue;
                    }
                    if (ch === "{") {
                        if (depth === 0) start = i;
                        depth++;
                        continue;
                    }
                    if (ch === "}") {
                        depth--;
                        if (depth === 0 && start !== -1) {
                            return text.slice(start, i + 1);
                        }
                    }
                }
                return null;
            }

            addSerialListener((evt) => {
                if (evt.direction !== "RX") return;
                if (!evt.line.startsWith("CFG ")) return;
                const jsonText = extractJsonObject(evt.line.slice(4).trim());
                if (!jsonText) {
                    console.error("CFG parse failed: no JSON object found");
                    showToast(t("sync_fail"));
                    return;
                }
                try {
                    const cfg = JSON.parse(jsonText);
                    applyConfigFromJson(cfg);
                    showToast(t("sync_ok"));
                } catch (err) {
                    console.error("CFG parse failed:", err);
                    showToast(t("sync_fail"));
                }
            });

            addSerialListener((evt) => {
                if (evt.direction !== "RX") return;
                if (!evt.line.startsWith("HOME ")) return;
                const jsonText = extractJsonObject(evt.line.slice(5).trim());
                if (!jsonText) {
                    console.error("HOME parse failed: no JSON object found");
                    return;
                }
                try {
                    const data = JSON.parse(jsonText);
                    applyHomeFromJson(data);
                } catch (err) {
                    console.error("HOME parse failed:", err);
                }
            });

            addSerialListener((evt) => {
                if (evt.direction !== "RX") return;
                if (!evt.line.startsWith("BOARD:")) return;
                if (evt.line.includes("Stepper")) {
                    setActiveAxisCount(6);
                    currentBoardType = "stepper";
                } else {
                    setActiveAxisCount(AXIS_NUM);
                    currentBoardType = "servo";
                }
                updateFwStatusText();
            });

            addSerialListener((evt) => {
                if (evt.direction !== "RX") return;
                if (!evt.line.startsWith("FW:")) return;
                const version = evt.line.slice(3).trim();
                currentFwVersion = version || "";
                const fw = document.getElementById("fwStatus");
                if (fw) {
                    const typeLabel = currentBoardType ? ` ${currentBoardType}` : "";
                    fw.textContent = `FW: ${version || "-"}${typeLabel}`;
                }
                if (!latestFirmware && !firmwareLoading) {
                    loadFirmwareList();
                } else {
                    updateFwStatusText();
                }
            });
        }

        init();
        registerSerialHandlers();
        applyLang();

    </script>

</body>

</html>
